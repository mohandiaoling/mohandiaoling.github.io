[
{
	"uri": "https://mohandiaoling.github.io/%E5%8D%9A%E5%AE%A2/",
	"title": "博客",
	"tags": [],
	"description": "",
	"content": "  博客内容创建\n  部署到github\n  文本内容编辑\n  博客内容创建  创建一个博客网站：hugo new site myblog（站点名，可自定义） 创建章节：hugo new --kind chapter \u0026lt;name\u0026gt;/_index.md 创建章节下页面：hugo new \u0026lt;name\u0026gt;/name.md 若要该页面显示，需删除draft: true 启动站点服务：hugo server (需要在myBlog目录下使用) 打开预览的快捷键：Ctrl+K+V (需要在英文输入状况下使用)   部署到github  在博客目录下打开cmd，输入hugo --theme=hugo-theme-learn --baseUrl=\u0026quot;https://mohandiaoling.github.io\u0026quot; --buildDrafts\n会在博客根目录 myblog 生成 public 文件夹，里面就是编译好的静态页面文件。 在public目录下：运行git bash，执行 git init将public文件夹变成 git 本地仓库 执行git add .将文件夹所以文件放入暂存区 执行 git commit -m \u0026quot;提交文件\u0026quot; 提交暂存区到本地仓库中 执行git remote add origin git@github.com:mohandiaoling/mohandiaoling.github.io.git添加远程版本库 然后执行git pull 执行git push -u origin master -f将本地仓库代码推送到远程库 执行git push -u origin master,直到出现Everything up-to-date。 最后，在浏览器中访问 https://mohandiaoling.github.io/ ，即可看到自己的博客网站。   文本内容编辑  标题：按#，从一到六，标题从大到小，一个#号时，标题位于中间。并且#与后面文档有一个空格。例如:  # h1 Heading ## h2 Heading ### h3 Heading #### h4 Heading ##### h5 Heading ###### h6 Heading 效果为：\nh1 Heading h4 Heading h5 Heading h6 Heading  注释：\u0026lt;!-- 注释内容 --\u0026gt;与html相同 主题分隔：（1）三个连续的下划线 （2）三个连续的破折号 （3）三个连续的星号。这三个显示是一样的。例如：___,***.---.\n效果为：    代码突出显示：在代码俩边分别加上```（英文下）。 页面换行：在一行后面加俩个空格，再按回车 粗体文本：在文本俩侧各加上俩个**，例如：**rendered as bold text**\n效果为：rendered as bold text 斜体文本：在文本俩侧各加上一个下划线，例如：**rendered as bold text**\n效果为：rendered as italicized text 删除线：文本俩侧各加上俩个波浪线,例如：~~Strike through this text.~~\n效果为：Strike through this text. 引用文档中其他来源的内容块：在要引用的任何文本之前添加\u0026gt;。注意\u0026gt;需要放在一行的最前面。例如：  \u0026gt; **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 效果为：\n Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined.\n也可用于嵌套：例如\n \u0026gt; **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 效果为：\n Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi.\n Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam.\n Mauris sit amet ligula egestas, feugiat metus tincidunt, luctus libero. Donec congue finibus tempor. Vestibulum aliquet sollicitudin erat, ut aliquet purus posuere luctus.\n  无序列表：在文本前加上*,-或者+。例如：  * valid bullet - valid bullet + valid bullet 效果为：\n valid bullet   valid bullet   valid bullet 还可以嵌套使用，例如：  + Facilisis in pretium nisl aliquet + Nulla volutpat aliquam velit - Phasellus iaculis neque - Purus sodales ultricies - Vestibulum laoreet porttitor sem - Ac tristique libero volutpat at 效果为：\n Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit  Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at   有序列表：在其前加上数字，是否加上空格会有不同效果，例如：  1. Lorem ipsum dolor sit amet 4.Consectetur adipiscing elit 2.Integer molestie lorem at massa 8. Facilisis in pretium nisl aliquet 4.Nulla volutpat aliquam velit 99.Faucibus porta lacus fringilla vel 21.Aenean sit amet erat nunc 6. Eget porttitor lorem 效果为：\n Lorem ipsum dolor sit amet 4.Consectetur adipiscing elit 2.Integer molestie lorem at massa Facilisis in pretium nisl aliquet 4.Nulla volutpat aliquam velit 99.Faucibus porta lacus fringilla vel 21.Aenean sit amet erat nunc Eget porttitor lorem  只有加上空格才会有序排列，就算文本前面数字混乱，也会按照从上到下依次排序。\n 表格：通过将管道添加为每个单元格之间的分隔线，并在标题下添加一行短划线（也由条形分隔）来创建表。请注意，管道不需要垂直对齐。例如：  | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 效果为：\n   Option Description     data path to data files to supply the data that will be passed into templates.   engine engine to be used for processing templates. Handlebars is the default.   ext extension to be used for dest files.     表格右对齐：在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐。例如：  | Option | Description | | ------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 效果为：\n   Option Description     data path to data files to supply the data that will be passed into templates.   engine engine to be used for processing templates. Handlebars is the default.   ext extension to be used for dest files.     链接：将鼠标悬停在链接上，没有工具提示。例如：[Assemble](http://assemble.io) 效果为：Assemble 添加工具提示：将鼠标悬停在链接上，应该有一个工具提示。与链接格式不同的是，后面“”里面有工具提示内容。例如：  [Upstage](https://github.com/upstage/ \u0026#34;Visit Upstage!\u0026#34;) 效果为：Upstage\n 图像：图像具有与链接类似的语法，但包含前面的感叹号。例如： ![Minion](https://octodex.github.com/images/minion.png)\n效果为： 图像的替代用法：例如：![Alt text][id]然后在文档后面加上[id]: https://octodex.github.com/images/dojocat.jpg \u0026quot;The Dojocat\u0026quot; 调整图片大小：将 HTTP 参数和/或添加到链接图像以调整图像大小。值是 CSS 值（默认值为 ）。例如：![Minion](https://octodex.github.com/images/minion.png?height=50px\u0026amp;width=300px) 效果为： 命名锚点：能够跳转到同一页面上的指定锚点。例如：```# Table of Contents  Chapter 1 Chapter 2 Chapter 3  效果为：# Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) ()里面中#后面的就是标题的名称  "
},
{
	"uri": "https://mohandiaoling.github.io/%E7%BD%91%E7%9B%98%E6%94%BB%E9%98%B2/",
	"title": "网盘攻防",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mohandiaoling.github.io/%E7%94%B5%E8%B5%9B/",
	"title": "电赛",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mohandiaoling.github.io/%E5%8D%9A%E5%AE%A2/%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5/",
	"title": "相关链接",
	"tags": [],
	"description": "",
	"content": " 同步 Github 和 Gitee  "
},
{
	"uri": "https://mohandiaoling.github.io/%E7%94%B5%E8%B5%9B/stm32%E7%9A%84%E5%AD%A6%E4%B9%A0/",
	"title": "Stm32的学习",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mohandiaoling.github.io/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "这里是陌寒凋零的博客 "
},
{
	"uri": "https://mohandiaoling.github.io/%E7%BD%91%E7%9B%98%E6%94%BB%E9%98%B2/%E8%BF%87%E6%BB%A4%E5%99%A8/",
	"title": "过滤器",
	"tags": [],
	"description": "",
	"content": " 过滤器： Filter即为过滤，用于在Servlet之外对Request或者Response进行修改。 具体流程：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。  在一个web应用中，可以开发编写多个Filter，这些Filter组合起来就是Filter链。过滤器可以规定过滤的页面。 在HttpServletRequest到达Servlet之前，拦截客户的HttpServletResquest。根据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。 在HttpServletResponse到达客户端之前，拦截HttpServletResponse。根据需要检查HttpServlet，也可以修改HttpServletResponse头和数据。   步骤：  编写java类实现Filter接口，并实现doFilter方法。 通过@WebFilter注解设置其所能拦截的资源。   乱码处理：\n1. 处理POST请求 2. 处理GET请求且服务器在Tomcat8以下\n具体代码：   package com.test.bean; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.UnsupportedEncodingException; //处理乱码问题 /** * 过滤器 * 1、@WebFilter(\u0026#34;/*\u0026#34;) 配置拦截的资源路径 * 2、doFilter()方法中要设置放行，否则无法到达资源（filterChain.doFilter(servletRequest,servletResponse);） * 3、如果是过滤器链，请求时是先配置的先执行（首字母在前的先执行）；而响应时顺序是反过来的 * **/ //拦截的路径，指拦截哪里的资源 //若填\u0026#34;/*\u0026#34;则代表拦截所有的请求 @WebFilter(\u0026#34;/*\u0026#34;) public class Filter1 implements Filter { //初始化 @Override public void init(FilterConfig filterConfig) throws ServletException { } //过滤 @Override public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse,FilterChain filterChain)throws ServletException, IOException{ //基于HTTP HttpServletRequest request=(HttpServletRequest)servletRequest; HttpServletResponse response=(HttpServletResponse)servletResponse; //处理请求乱码（处理POST请求） request.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); //处理GET请求且服务器版本在Tomcat8以下的 String method=request.getMethod(); //如果是GET请求 if(\u0026#34;GET\u0026#34;.equalsIgnoreCase(method)){ //服务器版本在Tomcat8以下的Apache Tomcat/8.0.45 String serverInfo=request.getServletContext().getServerInfo(); //得到具体版本号 String versionStr=serverInfo.substring(serverInfo.indexOf(\u0026#34;/\u0026#34;))+1; serverInfo.indexOf(\u0026#34;.\u0026#34;); //判断服务器版本是否小于8 if(Integer.parseInt(versionStr)\u0026lt;8){ //得到自定义内部类 （MyWrapper继承了HttpServletWrapper对象，而HttpServletRequestWrapper // 对象实现了HttpServletRequest接口，所以MyWrapper的本质也是request对象） HttpServletRequest myRequest= new MyWrapper(request); //放行资源 filterChain.doFilter(myRequest,response); return; } } //doFilter()放行方法前做请求拦截 //放行资源，若无这个放行资源，则会被一直拦截 filterChain.doFilter(request,response); //doFilter()方法后做响应请求 } //销毁 @Override public void destroy(){ } //定义内部类，继承HttpServletRequestWrapper包装类对象，重写getParameter()方法 class MyWrapper extends HttpServletRequestWrapper { //定义成员变量，提升构造器中的request对象的范围 private HttpServletRequest request; public MyWrapper(HttpServletRequest request) { super(request); this.request = request; } //重写getParameter()方法 @Override public String getParameter(String name) { String value = request.getParameter(name); if (value != null \u0026amp;\u0026amp; !\u0026#34;\u0026#34;.equals(value.trim())) { try { //将默认ISO-8859-1编码的字符转换成UTF-8 value = new String(value.getBytes(\u0026#34;ISO-8859-1\u0026#34;), \u0026#34;UTF-8\u0026#34;); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } return value; } } }  过滤特殊字符:  package com.test.bean; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.regex.PatternSyntaxException; public class Check { public static boolean checkSpecialChar(String str) throws PatternSyntaxException { String regEx = \u0026#34;[!@#$%^\u0026amp;*！@#￥%……/\u0026amp;*]\u0026#34;; Pattern pattern = Pattern.compile(regEx); Matcher matcher = pattern.matcher(str); return matcher.find(); } } 使用时，用\nboolean flag = Check.checkSpecialChar(fileName);  将特殊字符变成*号  package com.test.bean; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.util.ArrayList; import java.util.List; //过滤特殊字符 @WebFilter(\u0026#34;/indexServlet\u0026#34;) public class CharacterFilter implements Filter { /** * 这个适合用于使用一个包含许多特殊字符的文档 * private static List\u0026lt;String\u0026gt; list = null; // 敏感字集合 static { BufferedReader br = null; // 字符缓存流 list = new ArrayList\u0026lt;String\u0026gt;(); try { // 获取resources下指定文件路径 String fileName = CharacterFilter.class.getClassLoader().getResource(\u0026#34;name.txt\u0026#34;).getPath();//获取文件路径 // System.out.println(fileName); br = new BufferedReader(new FileReader(fileName)); String str = null; while ((str = br.readLine()) != null){ //读取数据 list.add(str); //添加到集合 } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally{ if (br != null) { try { br.close();//释放资源 } catch (IOException e) { e.printStackTrace(); } } } } **/ @Override public void init(FilterConfig filterConfig) throws ServletException { Filter.super.init(filterConfig); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { //强制类型转换 HttpServletRequest request=(HttpServletRequest)servletRequest; HttpServletResponse response=(HttpServletResponse) servletResponse; //定义特殊字符可能包含哪些 List\u0026lt;String\u0026gt; list=new ArrayList\u0026lt;String\u0026gt;(); list.add(\u0026#34;\u0026lt;22\u0026#34;); //过滤特殊字符 //创建动态代理对象 ServletRequest Proxy_Request = (ServletRequest) Proxy.newProxyInstance(request.getClass().getClassLoader(), request.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName().equals(\u0026#34;getParameter\u0026#34;)) { // 判断是否是getParameter()、增强getParameter()方法 String value = (String) method.invoke(request, args); //增强返回值 if (value != null) { for (String str : list) { //遍历敏感字 if (value.contains(str)) { // 验证是否包含 StringBuilder sb = new StringBuilder(); int length = str.length(); for (int i = 0; i \u0026lt; length; i++) { sb.append(\u0026#34;*\u0026#34;); // 添加星号 } value = value.replace(str,sb.toString()); // 将敏感字替换为*、然后将值重新复制给value变量 } } } return value; // 将新的值返回出去 } return method.invoke(request,args); //执行方法 } }); /* 这个调用chain.doFilter(request,response);//方法就是将执行下一个过滤器、或xxxServlet 如果没有下一个过滤就执行xxxServlet然后就会根据你的请求执行对应的get/post方法 * */ // 这里要注意这里传递过去的是增强后的代理对象 filterChain.doFilter(Proxy_Request,response);//简单来说这个就好比如过滤完成放行的意思/ } @Override public void destroy() { Filter.super.destroy(); } } "
},
{
	"uri": "https://mohandiaoling.github.io/%E7%BD%91%E7%9B%98%E6%94%BB%E9%98%B2/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E9%93%BE%E6%8E%A5/",
	"title": "常见问题解决链接",
	"tags": [],
	"description": "",
	"content": " Java教程 IDEA新手使用教程（详解） Java项目开发实战入门 Jetbrains系列产品重置试用方法归档 java.net.BindException: Address already in use: bind 解决端口号被占用 tomcat启动失败：初始化组件[Connector[HTTP/1.1-8080]]失败 解决tomcat正常启动但是对应的网页却无法访问 Tomcat安装及配置 JavaWeb入门登录注册系统 windows无法终止PID的进程，拒绝访问 MySQL 下载安装教程 官网下载mysql的jar包及导入到java项目中 MySQL的详细安装教程 MySQL 教程  MySQL数据库教程视频 JavaWeb教程目录 尚硅谷 2022 最新 IntelliJ IDEA 详细配置步骤演示 IDEA破解教程 IDEA MyEclipse Eclipse 快捷键大全(最终版) Tomcat启动闪退的原因和解决方法 javaweb项目的文件结构 idea中request获取不到getParameter方法 如何查看自己电脑主机的IP地址 IDEA Java web项目搭建以及连接Mysql数据库 通过IntelliJ IDEA软件实现Java项目连接MySQL的详细过程 解决Loading class com.mysql.jdbc.Driver‘. This is deprecated. The new driver class is com.mysql.cj.j 菜鸟教程 Servlet-实现用户的注册功能 Mysql数据库中有哪些数据类型? IntelliJ IDEA 2022.1永久破解激活教程（最新版，亲测可用） CSS参考手册 Java中带返回值方法定义和调用  "
},
{
	"uri": "https://mohandiaoling.github.io/%E7%94%B5%E8%B5%9B/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E9%93%BE%E6%8E%A5/",
	"title": "常见问题解决链接",
	"tags": [],
	"description": "",
	"content": " 立创元器件封装库导入AD的详细教程 立创元器件封装库导入AD AD19\u0026mdash;彻底解决原理图转PCB时，出现failed to add class member及Unknown Pin的问题 AD19导出Gerber文件-嘉立创打板  "
},
{
	"uri": "https://mohandiaoling.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mohandiaoling.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]